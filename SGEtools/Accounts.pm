package SGEtools::Accounts;

=head1 NAME

 SGEtools::Accounts - helper functions for processing (Son of) Grid Engine job logs

=head1 SYNOPSIS

 use SGEtools::Accounts;

 my %record;

 SGEInit ();

 print "Accounting files:\n";
 SGEPrintAccountFiles ();

 while (%record = SGEReadRecord ()) {
     SGEPrintRecord (%record);
 }

=head1 DESCRIPTION

SGEtools::Accounts is a compilation of helper functions to make it easy to process
text-based job logs from (So)GE in order to enable functionality beyond the basics offered
by qacct(1). A passing familiarity with Grid Engine's accounting(5) format is recommended
before using this module.

The module will gracefully handle log-rotated accounting files, including logs which
have been compressed using any format supported by IO::Uncompress::AnyUncompress

A simple script to demonstrate the functionality is shown in the synopsis.  
The syonpsis script will iterate through all records in all automatically-detected
logfiles and print them out in a format similar (but not identical) to the output from "qacct -j"

=head1 USAGE

=cut

use strict;
use warnings;

our $VERSION;
$VERSION = '1.0';

our (@ISA, @EXPORT);

BEGIN {
  require Exporter;
  @ISA = qw(Exporter);
  @EXPORT = qw(SGEInit SGEReadRecord SGEPrintRecord SGEPrintAccountFiles);
}

require IO::Uncompress::AnyUncompress;
use POSIX qw(strftime);

my $accfile;         # Location current account file
my $logfilepattern;  # Regexp to match (logrotated) logfiles
my @sorted_acclist;  # Global sorted list of logrotated account files
my $currfp;          # Current file pointer
my @acclist;         # List of accounting files to read

my @headers = ("qname", "hostname", "group", "owner", "job_name", "job_number",
               "account", "priority", "submission_time", "start_time", "end_time",
               "failed", "exit_status", "ru_wallclock", "ru_utime", "ru_stime",
               "ru_maxrss", "ru_ixrss", "ru_ismrss", "ru_idrss", "ru_isrss",
               "ru_minflt", "ru_majflt", "ru_nswap", "ru_inblock", "ru_oublock",
               "ru_msgsnd", "ru_msgrcv", "ru_nsignals", "ru_nvcsw", "ru_nivcsw",
               "project", "department", "granted_pe", "slots", "task_number",
               "cpu", "mem", "io", "category", "iow", "pe_taskid", "maxvmem",
               "arid", "ar_sub_time");

# Set default accfile value to $SGE_ROOT/$SGE_CELL/common/accounting
# and default logfile pattern accordingly

if (defined $ENV{'SGE_ROOT'} && $ENV{'SGE_CELL'}) {
   $accfile = $ENV{'SGE_ROOT'} . "/" . $ENV{'SGE_CELL'} . "/common/accounting";
   $logfilepattern = $accfile . "*";
} else {
   $accfile = "";
   $logfilepattern = "";
}

=pod

=over

=item C<SGEInit()>

Initialises a list of logfiles to be be scanned by SGEReadRecord(). When no arguments
are supplied and the shell contains the SGE_ROOT and SGE_CELL environment variables the 
constructed list will consist of $SGE_ROOTn (active) accounting file /$SGE_CELL/common/accounting and
all files matching the glob "$SGE_ROOT/$SGE_CELL/common/accounting-*", which are assumed to be
log-rotated accounting files.

The first (optional) argument should contain a string used to override the
file glob pattern for log-rotated files (e.g. "/var/log/accounting*"). If the empty
string ("") is used, no log-rotated files will be selected.

The second (optional) argument can be used to override the location of the main (active)
logfile. If the empty string is used (""), the main (active) accountiing file will not be selected.

NOTE: the list of selected files is guaranateed to have only unique entries, even if the glob
pattern also captures the main accounting file.
=cut

sub SGEInit {
  # Create list of accounting (log) files
  my $x;
  my @tmpacclist;
  my %tmptable;

  if (@_) {
    $logfilepattern = shift (@_);
  }

  if (@_) {
    $accfile = shift (@_);
  }

  if (@_) {
     die ("Invalid number of arguments to SGEtools::Accounts::Init()");
  }

  if ($logfilepattern ne "") {
     @tmpacclist = glob ($logfilepattern);
  }

  foreach $x (@tmpacclist) {
    $tmptable{$x} = 1;
  }

  if ($accfile ne "") {
     $tmptable{$accfile} = 1;
  }

  @sorted_acclist = (sort keys %tmptable);

  if ($#sorted_acclist == -1) {
     die "No account file or rotated logs detected";
  }
};

=pod

=item C<SGEPrintAccountFiles()>

This function will print to stdout the list of logfiles selected by SGEInit(). It is intended
for debugging purposes only.
=cut

sub SGEPrintAccountFiles {
   my $fn;

   foreach $fn (@sorted_acclist) {
     print "$fn\n";
   }
}

=pod

=item C<SGEReadRecord()>

After SGEInit() has been called, successive calls to this function will return
the next record from the list of selected accounting files. The function will cycle
through all log files generated by SGEInit().

Each record is in the form of an associative array whose elements correspond to
the field/record names in accounting(5)
=cut

# Read next account log entry and return as associative array
# On EOF, skip to next file in @sorted_acclist

sub SGEReadRecord {
   my %record;
   my $line;
   my @fields;
   my $x;

   if (! defined ($currfp) || eof ($currfp)) {
     SGEOpenNextAccountFile ();
   }

   if (!eof ($currfp)) {
     $line = <$currfp>;
     chomp $line;
     @fields = split(/:/, $line);

     for ($x = 0; $x<45; $x++) {
       $record{$headers[$x]} = $fields[$x];
     }
   }

   return %record;
};

# Open next account file in @sorted_acclist
# Handles normal and gzipped files

sub SGEOpenNextAccountFile {
  my $fn = shift @sorted_acclist;

  if (!$fn) {
    return undef
  }

  $currfp = new IO::Uncompress::AnyUncompress $fn || die "Failed to open file $fn";
}

=pod

=item C<SGEPrintRecord()>

This function will print out a summary of the job record passed as its first argument.
The format is similar - but not indenitcal - to the format used for qacct(1)'s -j option
=cut

sub SGEPrintRecord {

  my %record = @_;
  my $i;

  print "==============================================================\n";

  for ($i=0; $i < 45; $i++) {
    if ($i == 8) # qsub_time
         { 
           if ($record{$headers[$i]} == 0) { 
              printf ("%-12s %s\n", "qsub_time", "-/-");
           } else { 
              printf ("%-12s %s\n", "qsub_time", strftime ("%a %b %d %H:%M:%S %Y", localtime($record{$headers[$i]})));
           }
         }
    elsif ($i > 8 && $i < 11) # start/end
         { 
           if ($record{$headers[$i]} == 0) { 
              printf ("%-12s %s\n", $headers[$i], "-/");
           } else {
              printf ("%-12s %s\n", $headers[$i], strftime ("%a %b %d %H:%M:%S %Y", localtime($record{$headers[$i]})));
           }
         }
    elsif (($i > 12 && $i < 16) || $i == 36 || $i == 40) # Time in seconds
         { printf ("%-12s %.3fs\n", $headers[$i], $record{$headers[$i]}); }
    elsif (($i > 15 && $i < 21) || $i == 37 || $i == 42) # Byte count
         { printf ("%-12s %s\n", $headers[$i], SGEHrBytes($record{$headers[$i]})); }
    elsif ($i == 38) # GBs count
         { printf ("%-12s %sGBs\n", $headers[$i], $record{$headers[$i]}); }
    elsif (($i == 34 || $i == 43 || $i == 44) && $record{$headers[$i]} == 0) # 0 => undefined
         { printf ("%-12s %s\n", $headers[$i], "undefined"); }
    else 
         { printf ("%-12s %s\n", $headers[$i], $record{$headers[$i]}); }
  }
}

# Convert byte into human-readable format
 
sub SGEHrBytes {
   my $val = shift;
   my @units = ("B", "KB", "MB", "GB", "TB");
   my $currunit = shift (@units);

   while (@units && $val > 1024.0) {
     $val /= 1024.0;
     $currunit = shift (@units);
   }

  return (sprintf ("%.3f", $val) . $currunit);
}

=pod

=back
=cut
return 1;

